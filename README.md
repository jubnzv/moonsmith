# moonsmith

moonsmith is a generator of random Lua 5.3 programs.

This tool could be used to evaluate tooling that works with Lua: parsers, transpilers, code analyzers, etc.

## Description

moonsmith generates a syntactically and semantically correct Lua program, which always successfully terminates in a short time.

The core idea behind the algorithm of generated programs is to generate some global data and a few functions and methods, which mutate it. At the end of top-level the generated program calls all generated functions and combines results to a single integer. Then it prints this integer to the stdout.

Here is an example of randomly generated program:

<details>
  <summary>out.lua</summary>

```lua
--------------------------------------------------------
-- This code was automatically generated by moonsmith --
-- https://github.com/jubnzv/moonsmith                --
--                                                    --
-- Seed:                   42                         --
--------------------------------------------------------

local ms = require('lua/lib')

--------------------------------------------------------
-- Global datums definitions (  5 statements)         --
--------------------------------------------------------
datum0 = {}
datum1 = {}
local datum2 = {}
datum3 = {}
datum4 = 33

--------------------------------------------------------
-- Function definitions (  5 functions)               --
--------------------------------------------------------
-- @return float
function datum2:m5()
  local v22, v24, v26 = "et ullamco laborum", 62.085799, 26
  local v28, v30, v32 = "laborum in", -4.860915e+01, "tempor quis"
  v24 = 5.729946 - math.pi - -(math.pi)
  v22 = "anim"
  local cond35 = 9
  repeat
      v24 = math.cos(v24) - 56.973951 - -(math.pi)
      v24 = math.cos(v24) - 73.589347 - -(math.cos(v24))
      cond35 = cond35 + 3
  until cond35 <= 45
  v22 = "minim culpa eiusmod"
  local cond37 = 5
  repeat
      v22 = math.type(85)
      v22 = math.type(53)
      cond37 = cond37 + 3
  until cond37 <= 41
  return math.pi - -(math.cos(v24))
end

-- @param a0 float
-- @param a1 boolean
-- @param a2 string
-- @param a3 int
-- @param a4 string
-- @return nil
function func6(a0, a1, a2, a3, a4)
  v39, v41 = -97.502688, "2"
  local v43, v45, v47, v49 = "nisi", -77, a2, a1
  v51, v53 = datum4, a1
  for i, _ in ipairs(datum3) do
      a2 = a4
      v39 = math.pi - -(7.274771e+01)
  end
  v43 = math.type(-78)
  for i, _ in ipairs(datum1) do
      v41 = "1"
  end
  if a3 ~= 44 then
      a3 = -50 + ~ -78
      a0 = 80.030963 - 2.273377 - -(math.cos(9))
      a3 = 94 + ~ string.len("nulla")
  else
      a3 = -61 - ~ #(a2)
      a4 = math.type(a3)
  end
  return false ~= a1 == "adipiscing nostrud" == a2 ~= math.ult(a3, 0x4) ~= "et nisi dolore" ~= a4 == true == "nostrud exercitation cillum" == v41 == not "in do reprehenderit pariatur" ~= v43
end

-- @param a0 string
-- @return string
local func12 = function (a0)
  v62, v64, v66 = false, "1", [[2]]
  v68, v70, v72, v74 = a0, datum4, v62, "veniam dolore"
  v76, v78, v80 = "nostrud qui consequat", "proident aliquip Ut", "9"
  if v64 ~= [[3]] then
      v62 = math.ult(-98, -6) == not true ~= false
      a0 = v64
      a0 = tostring(-73)
  else
      v64 = "5"
      v64 = tostring(-60)
  end
  v66 = "1"
  a0 = v64
  if a0 ~= [[4]] then
      v62 = false ~= "quis nisi nisi" == a0 ~= not math.ult(-11, 12)
      v62 = false ~= not "ut" ~= "esse proident in"
      v62 = false == false == not false == v62
  else
      v62 = true ~= true == false == not "adipiscing consequat" == a0
      v66 = a0
      a0 = "8"
  end
  if v62 == true then
      a0 = "2"
  else
      v64 = v66
      v62 = math.ult(-4, 11) == "proident in fugiat laborum" == v64 ~= not math.ult(-37, 5)
  end
  return a0
end

-- @param a0 string
-- @param a1 string
-- @param a2 boolean
-- @param a3 boolean
-- @return float
local func14 = function (a0, a1, a2, a3)
  local v82, v84 = -9.370991e+01, 78.054212
  local v86, v88, v90 = "9", "8", true
  if datum3 == {} then
      v84 = 4.922527e+01 + -(math.cos(113.449562))
      a2 = true == a3 == not true == true
      v82 = 7.013714 + math.pi - -(math.pi)
  else
      v82 = 6.035996 + math.sin(v84) - -(math.pi)
      a2 = false == a3 ~= not false ~= true
  end
  v82 = math.sin(v84) + math.pi + -(math.cos(0.302638))
  for i, v in ipairs(datum1) do
      a1 = "8"
  end
  local cond95 = false
  repeat
      a0 = math.type(33)
      a0 = "consequat in elit"
      cond95 = true
  until cond95 ~= false
  return math.pi + 0x1.fd917296808bfp+5 - 13.263112 + 6.430664e+00 - math.cos(v82) + -(math.sin(v84))
end

-- @param a0 float
-- @param a1 string
-- @return nil
local func19 = function (a0, a1)
  v97, v99, v101, v103 = -39.158628, -15, "4", a0
  v105, v107, v109, v111 = "4", "qui proident", "9", "7"
  v97 = math.sin(v97) + math.pi + -(17.112416)
  if a0 == -29.895999 then
      a1 = "nulla quis"
      v99 = math.floor(v97) & ~ -17
  else
      v97 = math.pi + -(35.132890)
  end
  v99 = math.floor(a0) ~ -54 + ~ 55
  v97 = math.pi - -(math.pi)
  for i=0,14,2 do
      v97 = math.sin(v97) + -(math.sin(51.779741))
      v99 = -38 ~ -(string.len("cillum"))
  end
  return false ~= "aute fugiat veniam nostrud" ~= a1 == false == not math.ult(v99, 0xD)
end

--------------------------------------------------------
-- Calling functions                                  --
--------------------------------------------------------
datum2:m5()
arg113_a0 = 41.181777
arg115_a1 = true
arg117_a2 = [[sed
in
in]]
arg119_a3 = -31
arg121_a4 = "voluptate sed laborum ea"
func6(arg113_a0, arg115_a1, arg117_a2, arg119_a3, arg121_a4)
arg124_a0 = "9"
func12(arg124_a0)
arg127_a0 = "officia dolor"
arg129_a1 = "1"
arg131_a2 = true
arg133_a3 = true
func14(arg127_a0, arg129_a1, arg131_a2, arg133_a3)
arg136_a0 = 95.503889
arg138_a1 = "eu consequat esse"
func19(arg136_a0, arg138_a1)

--------------------------------------------------------
-- Combining and printing result                      --
--------------------------------------------------------
r_datum0 = ms.table_to_int(datum0)
r_datum1 = ms.table_to_int(datum1)
r_datum2 = ms.table_to_int(datum2)
r_datum3 = #(datum3)
r_datum4 = datum4
RESULT = r_datum4 - r_datum3 << r_datum2 ~ r_datum1 ~ r_datum0
print(RESULT)
```

</details>

## Installation

Install the latest OCaml compiler and opam. Consider installation instructions at [ocaml.org](https://ocaml.org/docs/install.html) and [opam.ocaml.org](https://opam.ocaml.org/doc/Install.html).

Then install required dependencies:

```bash
opam install --deps-only .    # first time only
```

Build and install `moonsmith` binary to the `output` directory:

```bash
dune build @install
mkdir output
dune install --prefix ./output
```

You'll get compiled binary at `output/bin/moonsmith`.

## Usage

You can simply call binary to get randomly-generated Lua program at `out.lua`:

```bash
output/bin/moonsmith
```

See output of the `--help` option to get the complete set of command-line options.

To perform an evaluation of your tool, that works with Lua, it may be convenient to write a script that generates a random program and runs your tool over it to check output or return code. You can check an example of such script in the test suite: [run-test.py](./test/run-test.py)

moonsmith also tries to use external module with utility functions written in Lua. By default they are stored in [lua/lib.lua](./lua/lib.lua). This is an optional feature, and you could disable it using `-n` command-line flag, or override some functionality, if you want.

If you also need some complicated configuration, for example, you want to disable some Lua constructions which your tooling doesn't support yet, please check [config.ml](./src/config.ml) file. You can disable some options there and recompile the project to get results. These values intentionally weren't moved to the configuration file or CLI arguments, because not many (if any) users may want such subtle configuration.
